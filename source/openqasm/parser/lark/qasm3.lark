// Lark grammar for OpenQASM3.0

// Parser grammar

program: header (global_statement | statement)*

header: [version] include* io*

version: "OPENQASM" (INTEGER | REAL) _SEMICOLON

include: "include" STRINGLITERAL _SEMICOLON

io_identifier: (INPUT | OUTPUT)

io: io_identifier classical_type IDENTIFIER _SEMICOLON

global_statement: subroutine_definition
                | extern_declaration
                | quantum_gate_definition
                | calibration
                | quantum_declaration_statement
                | pragma

statement: expression_statement
         | assignment_statement
         | classical_declaration_statement
         | branching_statement
         | loop_statement
         | end_statement
         | alias_statement
         | quantum_statement

quantum_declaration_statement: quantumdeclaration _SEMICOLON

classical_declaration_statement:
        (classical_declaration | constant_declaration) _SEMICOLON

classical_assignment:
        IDENTIFIER designator? assignment_operator expression

assignment_statement:
        (classical_assignment | quantum_measurement_assignment) _SEMICOLON

return_signature: ARROW classical_type

// Types and casting

designator: _LBRACKET expression _RBRACKET

identifier_list: IDENTIFIER ("," IDENTIFIER)*

// Quantum types
quantum_declaration: "qreg" IDENTIFIER designator?
                   | "qubit" designator? IDENTIFIER

quantum_argument: "qreg" IDENTIFIER designator?
                   | "qubit" designator? IDENTIFIER

quantum_argument_list: quantum_argument ("," quantum_argument)*

// Classical types

bit_type: "bit" | "creg"

single_designator_type: "int"
                      | "uint"
                      | "float"
                      | "angle"

no_designator_type: "bool"
                  | timing_type

classical_type: single_designator_type designator
              | no_designator_type
              | bit_type designator?
              | "complex" _LBRACKET numeric_type _RBRACKET

// Numeric types
numeric_type: single_designator_type designator

constant_declaration: "const" IDENTIFIER equals_expression

// if multiple variables declared at once, either none are assigned or all are assigned
// prevents ambiguity with qubit arguments in subroutine calls

single_designator_declaration: single_designator_type designator IDENTIFIER equals_expression?

no_designator_declaration: no_designator_type IDENTIFIER equals_expression?

bitdeclaration: ("creg" indexidentifier | "bit" indexidentifier) equals_expression?

complex_declaration: "complex" _LBRACKET numeric_type _RBRACKET IDENTIFIER equals_expression?

classical_declaration: single_designator_declaration
                     | no_designator_declaration
                     | bit_declaration
                     | complex_declaration

classical_type_list: classical_type ("," classical_type)*

classical_argument: (single_designator_type designator | no_designator_type) IDENTIFIER
                  | "creg" IDENTIFIER designator?
                  | "bit" designator? IDENTIFIER
                  | "complex" _LBRACKET numeric_type _RBRACKET IDENTIFIER

classical_argument_list: classical_argument ("," classical_argument)*

any_type_argument: classical_argument | quantum_argument

any_type_argument_list: any_type_argument ("," any_type_argument)

// Aliasing

alias_statement: "let" IDENTIFIER "->" index_identifier _SEMICOLON

// Register concatenation and slicing

index_identifier: IDENTIFIER range_definition
                | IDENTIFIER (_LBRACKET expression_list _RBRACKET)?
                | index_identifier "||" index_identifier

index_identifier_list: index_identifier ("," index_identifier)*

range_definition: _LBRACKET expression? ":" expression? (":" expression)? _RBRACKET

// Gates and built-in quantum instructions

quantum_gate_definition: "gate" quantum_gate_signature quantum_block

quantum_gate_signature: quantum_gate_name (_LBRACKET identifier_list? _RBRACKET)? identifier_list

quantum_gate_name: "U"
                 | "CX"
                 | IDENTIFIER

quantum_block: _LBRACE (quantum_statement | quantum_loop)* _RBRACE

// Loops containing only quantum statements allowed in gates.
quantum_loop: loop_signature quantum_loop_block

quantum_loop_block: quantum_statement | _LBRACE quantum_statement* _RBRACE

quantum_statement: quantum_instruction _SEMICOLON
                 | timing_statement

quantum_instruction: quantum_gate_call
                   | quantum_phase
                   | quantum_measurement
                   | quantum_reset
                   | quantum_barrier

quantum_phase: quantum_gate_modifier* "gphase" _LPAREN expression _RPAREN index_identifier_list?

quantum_reset: "reset" index_identifier_list

quantum_measurement: "measure" index_identifier_list

quantum_measurement_assignment: quantum_measurement (ARROW index_identifier_list)?
                              | index_identifier_list "->" quantum_measurement

quantum_barrier: "barrier" index_identifier_list?

quantum_gate_modifier: ("inv" | pow_modifier | ctrl_modifier) "@"

pow_modifier: "pow" _LPAREN expression _RPAREN

ctrl_modifier: ("ctrl" | "negctrl") (_LPAREN expression _RPAREN)?

quantum_gate_call: quantum_gate_modifier* quantum_gate_name (_LPAREN expression_list _RPAREN)? index_identifier_list

// Classical instructions

unary_operator: "~" | "!" | "-"

comparison_operator: ">" | "<" | ">=" | "<="

equality_operator: "==" | "!="

logical_operator: "&&" | "||"

expression_statement: expression _SEMICOLON

expression: expression_terminator
          | unary_expression
          | logical_and_expression
          | expression "||" logical_and_expression

// Expression hierarchy for non-terminators. Adapted from ANTLR4 C
// grammar: https://github.com/antlr/grammars-v4/blob/master/c/C.g4
// Order (first to last evaluation):
// Terminator (including Parens),
// Unary Op,
// Multiplicative
// Additive
// Bit Shift
// Comparison
// Equality
// Bit And
// Exlusive Or (xOr)
// Bit Or
// Logical And
// Logical Or

logical_and_expression: bit_or_expression
                      | logical_and_expression "&&" bit_or_expression

bit_or_expression: xor_expression
                 | bit_or_expression "|" xor_expression

xor_expression: bit_and_expression
              | xor_expression "^" bit_and_expression

bit_and_expression: equality_expression
                  | bit_and_expression "&" equality_expression

equality_expression: comparison_expression
                   | equality_expression equality_operator comparison_expression

comparison_expression: bit_shift_expression
                     | comparison_expression comparison_operator bit_shift_expression

bit_shift_expression: additive_expression
                    | bit_shift_expression ("<<" | ">>") additive_expression

additive_expression: multiplicative_expression
                   | additive_expression (PLUS | MINUS) multiplicative_expression

multiplicative_expression: power_expression
                         | unary_expression
                         | multiplicative_expression (MUL | DIV | MOD) (power_expression | unary_expression)?

unary_expression: unary_operator power_expression

power_expression: expression_terminator | expression_terminator "**" power_expression

expression_terminator: CONSTANT
                     | INTEGER
                     | REALNUMBER
                     | IMAGNUMBER
                     | boolean_literal
                     | IDENTIFIER
                     | STRINGLITERAL
                     | builtin_call
                     | extern_or_subroutine_call
                     | timing_identifier
                     | _LPAREN expression _RPAREN
                     | expression_terminator _LBRACKET expression _RBRACKET

boolean_literal: "true" | "false"

builtin_call: (builtin_math | cast_operator) _LPAREN expression_list _RPAREN

builtin_math: "sin" | "cos" | "tan" | "exp" | "ln" | "sqrt" | "rotr" | "popcount"

cast_operator: classical_type

expression_list: expression ("," expression)*

equals_expression: "->" expression

assignment_operator: "->" | "+=" | "-=" | "*=" | "/=" | "&=" | "|=" | "~=" | "^=" | "<<=" | ">>=" | "%=" | "**=="

set_declaration: _LBRACE expression_list _RBRACE
               | range_definition
               | IDENTIFIER

program_block: statement | control_directive
             | _LBRACE (statement | control_directive) * _RBRACE

branching_statement: "if" _LPAREN expression _RPAREN program_block ("else" program_block )?

loop_signature: "for" IDENTIFIER "in" set_declaration
              | "while" _LPAREN expression _RPAREN

loop_statement: loop_signature program_block

end_statement: "end" _SEMICOLON

return_statement: "return" (expression | quantum_measurement)? _SEMICOLON

control_directive: ("break" | "continue") _SEMICOLON
                 | end_statement
                 | return_statement

extern_declaration: "extern" IDENTIFIER _LPAREN classical_type_list? _RPAREN return_signature? _SEMICOLON

// if have function call w out args, is ambiguous; may get matched as identifier
extern_or_subroutine_call: IDENTIFIER _LPAREN expression_list? _RPAREN

// Subroutines
subroutine_definition: "def" IDENTIFIER _LPAREN any_type_argument_list? _RPAREN return_signature? subroutine_block

subroutine_block: _LPAREN statement* return_statement? _RPAREN

// Directives

pragma: "#pragma" _LPAREN statement* _RPAREN // match any valid openqasm statement

// Circuit timing
timing_type: "duration" | "stretch"

timing_box: "box" designator? quantum_block

timing_identifier: TIMINGLITERAL
                 | "durationof" _LPAREN (IDENTIFIER | quantum_block ) _RPAREN

timing_instruction_name: "delay" | "rotary"

timing_instruction: timing_instruction_name (_LPAREN expression_list? _RPAREN)? designator index_identifier_list

timing_statement: timing_instruction _SEMICOLON
                | timing_box

// Pulse-level descriptions of gates and measurement
// TODO: Update when pulse grammar is formalized

calibration: calibration_grammar_declaraion
           | calibration_definition

calibration_grammar_declaration: "defcalgrammar" calibration_grammar _SEMICOLON

calibration_definition: "defcal" IDENTIFIER (_LPAREN calibration_argument_list? _RPAREN)? identifier_list
                        return_signature? _LPAREN /^(?!.*\))?/ _RPAREN

calibration_grammar: "\"openpulse\"" | STRINGLITERAL // currently: pulse grammar string can be anything

calibration_argument_list: classical_argument_list | expression_list

// Lexer grammars

%import common.SIGNED_INT -> INTEGER
%import common.SIGNED_NUMBER -> REALNUMBER
%import common.CNAME -> IDENTIFIER
%import common.ESCAPED_STRING -> STRINGLITERAL
%import common.WS

CONSTANT: ("pi" | "π" | "tau" | "𝜏" | "euler" | "ℇ" )
INPUT: "input"
OUTPUT: "output"
_IMAG: "im"
_SEMICOLON: ";"
_LBRACKET: "["
_RBRACKET: "]"
_LPAREN: "("
_RPAREN: ")"
_LBRACE: "{"
_RBRACE: "}"
IMAGNUMBER: (INTEGER | REALNUMBER) _IMAG
NEWLINE: [\r\n]+

%ignore NEWLINE
%ignore WS
